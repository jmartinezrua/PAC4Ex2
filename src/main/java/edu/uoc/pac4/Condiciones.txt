Ejercicio 2 (5 puntos) 
Antes de empezar debes: 

Abre el proyecto PAC4Ex2 de IntelliJ. En el package edu.uoc.pac4 del directorio /src/test/java está el archivo con los tests unitarios que te proporcionamos. Copia el package edu.uoc.pac4 del directorio/src/main/java del Ejercicio 1 de esta PEC4 una vez la hayas completado. 
En este ejercicio ampliamos el programa anterior añadiendo nuevas clases, interfaces y métodos. El nuevo diagrama de clases UML lo encontrarás en el zip del enunciado con el nombre PAC4Ex2.png. Es importante que lo consultes a menudo puesto que hay información, como los modificadores de acceso de los elementos, que es posible que no se comenten en este enunciado. 
Para que puedas tener una clara sobre la estructura que debe tener el proyecto, te proporcionamos una captura de pantalla donde aparecen todas las clases, interfaces y enumeraciones que se deben codificar dentro de sus respectivos packages. Debes mantener esta estructura en tu proyecto para poder ejecutar la colección de tests correctamente: 



Recomendación: En este ejercicio vamos a aprender a usar la estructura de datos LinkedList, que permite almacenar elementos en una lista enlazada. Podéis investigar más sobre ella en la documentación oficial de Java: https://docs.oracle.com/javase/8/docs/api/java/util/LinkedList.html. 
A continuación vamos a ir comentando cada uno de los elementos que aparecen en el diagrama de clases y en la captura anterior: 


Interface Evaluable 
Esta interfaz declara la firma del método que debe tener cualquier clase cuyos objetos puedan ser evaluables. Debe estar dentro del package edu.uoc.pac4.activity. 


Class ActivityException 
Esta clase debe definir todos los atributos y constructores que aparecen en el diagrama UML y, además, heredar de la clase Exception igual que en el ejercicio anterior. 

Class Activity 
Esta clase es abstracta, es decir, no se puede instanciar y tendrán que ser sus clases hijas las que se instancien. Por ello, hay que declararla como abstract. Además, representa una actividad que se puede ejecutar dentro de la aplicación DSLab. 
Para su implementación, hay que seguir la definición que se ha proporcionado en el diagrama UML. Además, hay que tener en cuenta las siguientes consideraciones: 
&#9679; 
La clase Activity debe implementar la interfaz Cloneable y deberá implementar el método clone, por ahora puedes dejar su signatura y codificarlo más adelante. 

&#9679; 
Esta clase tiene un atributo que representa una lista de ejecuciones (executions) para poder almacenar todas las ejecuciones que se han llevado a cabo de esta actividad. Para codificar este atributo debes usar la estructura de datos LinkedList. 

&#9679; 
setName: Si el nombre recibido por parámetro (name) es null, no contiene ningún carácter (String vacía) o solo està formado por espacios en blanco, el método debe lanzar una excepción de tipo ActivityException con el mensaje "[ERROR] Name cannot be null, empty or blank". En caso contrario, debe asignar el nombre de la actividad eliminando los posibles espacios en blanco que tenga al inicio y al final. 

&#9679; 
setDescription: Si la descripción recibida por parámetro (description) es null, el método debe asignar una String vacía. En caso contrario, debe asignar la descripción recibida por parámetro eliminando los posibles espacios en blanco que tenga al inicio y al final. 

&#9679; 
addExecution: Este método debe insertar la ejecución recibida por parámetro (execution) al final de la lista enlazada (executions). 

&#9679; 
getExecutions: Este método debe devolver una lista enlazada con todas las ejecuciones de esta instancia. Es decir, devolver el contenido del atributo executions. 

&#9679; 
clone: Este método debe realizar una copia de la actividad y devolverla. Para ello, debe clonar todos sus atributos, excepto la lista de ejecuciones (executions), que deberá estar vacía en la nueva copia. 

Requisito mínimo para evaluar este ejercicio: La implementación de este método se debe hacer con el método clone de la clase Object. 

&#9679; 
toString: Este método devuelve una cadena de caracteres con la información de una actividad siguiendo el siguiente formato: 




name: description Total executions: n 
Donde n corresponde al número de ejecuciones que se han llevado a cabo de esta actividad. 

Class ActivityProgramming 
Esta clase vuelve a ser abstracta, pero también hereda la clase Activity. Por lo tanto, esta clase será una clase hija de la clase Activity, permitiendo acceder a todos los atributos y métodos públicos y protegidos de la clase padre como si fueran suyos. 
Para su implementación, hay que tener en cuenta las siguientes consideraciones: 
&#9679; 
setWeight: Si el atributo que representa el peso de esta actividad en la nota final (weight) es inferior a 0 o superior a 100, este debe corregirse para que el valor asignado siempre esté dentro del rango [0, 100]. Una vez ajustado, en caso de que fuera necesario, el método asigna el peso. 

&#9679; 
toString: Este método devuelve una cadena de caracteres con la información de una actividad de programación incluyendo la información de la actividad que hereda de su clase padre. Debe seguir el siguiente formato: 



name: description Total executions: n (weight%) 

Enum ActivityQuizType 
Esta enumeración se debe implementar siguiendo las especificaciones del UML. Asimismo, cada uno de los literales debe tener la siguiente descripción (description): 
MULTIPLE_CHOICE &rarr; Collection of questions with multiple choices TRUE_FALSE &rarr; Collection of questions with true or false answers SHORT_ANSWER &rarr; Collection of questions with short answers 
Asimismo, hay que tener en cuenta la siguiente indicación: 
&#9679; toString: Este método debe devolver la descripción (description) del literal que representa la instancia. 

Class ActivityQuiz 
De nuevo, esta clase hereda de la clase Activity, por lo que tendrá acceso a los atributos y métodos públicos y protegidos de la clase padre. No obstante, esta clase no es abstracta, por lo que se podrá instanciar. 
Para su implementación, hay que tener en cuenta las siguientes consideraciones: 
&#9679; toString: Este método devuelve la información de la actividad seguido de una descripción del tipo de cuestionario que representa. Debe seguir el siguiente formato: 
name: description Total executions: n typeDescription 
Class ActivityProgrammingCpp 
Para su implementación, hay que tener en cuenta las siguientes consideraciones: 

&#9679; 
setCompiler: Si el compilador recibido por parámetro (compiler) es null, una cadena de caracteres vacía (String vacía) o sólo está formada por espacios en blanco, entonces debe lanzar una excepción de tipo ActivityException con el mensaje &ldquo;[ERROR] Compiler cannot be null, empty or blank&rdquo;. En caso contrario, debe asignar el compilador eliminando los posibles espacios en blanco que tenga al inicio y al final. 

&#9679; 
setStandard: Si el estándar recibido por parámetro (standard) es null, una cadena de caracteres vacía (String vacía) o sólo está formada por espacios en blanco, entonces debe lanzar una excepción de tipo ActivityException con el mensaje &ldquo;[ERROR] Standard cannot be null, empty or blank&rdquo;. En caso contrario, debe asignar el estándar eliminando los posibles espacios en blanco que tenga al inicio y al final. 

&#9679; 
toString: Este método devuelve la información de una actividad programada en C++. Debe seguir el siguiente formato: 


[C++] name: description Total executions: n (weight%) (compiler, standard) 

Class ActivityProgrammingJava 
Para su implementación, hay que tener en cuenta las siguientes consideraciones: 
&#9679; 
setJdkVersion: Si la versión del JDK recibida por parámetro (jdkVersion) es null o no contiene una versión válida, entonces debe lanzar una excepción de tipo ActivityException con el mensaje &ldquo;[ERROR] JDK version must be in the format x.y.z where y and z are optional&rdquo;. En caso contrario, asigna la versión del JDK. Se considera que una versión de JDK es correcta si solo está formada por números y puntos y sigue un formato como el siguiente: x.y.z, donde el valor de y y z son opcionales, es decir, el minor version y el patch version son valores opcionales a la hora de especificar la versión del JDK. 

&#9679; 
setGradleVersion: Si la versión de Gradle recibida por parámetro (gradleVersion) es null o no contiene una versión válida, entonces debe lanzar una excepción de tipo ActivityException con el mensaje &ldquo;[ERROR] Gradle version must be in the format x.y.z where z is optional&rdquo;. En caso contrario, asigna la versión de Gradle. Se considera que una versión de Gradle es correcta si solo está formada por números y puntos y sigue un formato como el siguiente: x.y.z, donde el valor de z es opcional, es decir, el patch version es un valor opcional a la hora de especificar la versión de Gradle. 

&#9679; 
toString: Este método devuelve la información de una actividad programada en Java. Debe seguir el siguiente formato: 



[Java] name: description Total executions: n (weight%) (jdk-jdkVersion, gradle vgradle) 

Class ActivityProgrammingPython 
Para su implementación, hay que tener en cuenta las siguientes consideraciones: 
&#9679; 
setPythonVersion: Si la versión de Python recibida por parámetro (pythonVersion) es null o no contiene una versión válida, entonces debe lanzar una excepción de tipo ActivityException con el mensaje &ldquo;[ERROR] Python version must be in the format x.y.z where z is optional&rdquo;. En caso contrario, asigna la versión de Python. Se considera que una versión de Python es correcta si solo está formada por números y puntos y sigue un formato como el siguiente: x.y.z, donde el valor de z es opcional, es decir, el patch version es un valor opcional a la hora de especificar la versión de Python. 

&#9679; 
toString: Este método devuelve la información de una actividad programada en Python. Debe seguir el siguiente formato: 


[Python] name: description Total executions: n (weight%) (pythonVersion, with virtualenv) 
Donde la cadena &ldquo;, with virtualenv&rdquo; solo se añade en caso de que se tenga que ejecutar bajo un entorno de ejecución virtual (usesVirtualEnv). 

Class UserException 
Esta clase debe definir todos los atributos y constructores que aparecen en el diagrama UML y, además, heredar de la clase Exception igual que en el ejercicio anterior. Debe estar dentro del package edu.uoc.pac4.user. 
Class User 
Esta clase vuelve a ser abstracta, por lo que no podrá ser instanciada. Para su implementación, hay que tener en cuenta las siguientes consideraciones: 
&#9679; 
setEmail: Si el correo recibido por parámetro (email) es null o no es un correo válido, entonces el método debe lanzar una excepción de tipo UserException con 

el mensaje &ldquo;[ERROR] The email must start with any character end with @uoc.edu&rdquo;. En caso contrario, debe asignar el correo recibido por parámetro. Se considera que un correo es válido si antes del carácter @ hay cualquier otro carácter y si siempre termina con la cadena de caracteres &ldquo;@uoc.edu&rdquo;. 

&#9679; 
setName: Si el nombre recibido por parámetro (name) es null, una cadena de caracteres vacía (String vacío) o está formado solo por espacios en blanco, entonces debe devolver una excepción de tipo UserException con el mensaje &ldquo;[ERROR] Name cannot be null, empty or blank&rdquo;. En caso contrario, debe asignar el nombre eliminando los espacios en blanco que pueda tener al inicio 

o al final. 

&#9679; 
setSurname: Si el apellido recibido por parámetro (surname) es null, entonces debe asignar una cadena de caracteres vacía. En caso contrario, debe asignar el apellido recibido eliminando los espacios en blanco que pueda tener al inicio o al final. 

&#9679; 
toString: Este método devuelve la información de un usuario. Debe seguir el siguiente formato: 



name surname (email) 


Class Student 
Esta clase hereda la clase User. Asimismo, tiene un atributo que permite almacenar las ejecuciones que ha ido haciendo en la aplicación (executions). Como ya ocurrió anteriormente, este atributo debe ser declarado usando una lista enlazada (LinkedList). Para poder implementarla, hay que seguir las siguientes especificaciones: 
&#9679; 
addExecution: Añade la ejecución que recibe por parámetro (execution) al final de la lista de ejecuciones (executions). 

&#9679; 
getExecutions: Este método debe devolver una lista enlazada con todas las ejecuciones de esta instancia. Es decir, devolver el contenido del atributo executions. 

&#9679; 
getLastExecutionSubmitted: Este método devuelve la referencia de la última ejecución que se ha insertado en la lista enlazada (executions). 

&#9679; 
toString: Este método devuelve la información de un estudiante. Debe seguir el siguiente formato: 



[STUDENT] name surname (email) Total executions: n 
Donde n corresponde al número de ejecuciones que ha llevado a cabo el estudiante. 

Class Professor 
Esta clase hereda la clase User. Asimismo, tiene un atributo que permite almacenar las actividades que ha creado en la aplicación (activities). Este atributo debe ser declarado usando una lista enlazada (LinkedList). Para poder implementarla, hay que seguir las siguientes especificaciones: 
&#9679; 
addActivity: Añade la actividad que recibe por parámetro (activity) al final de la lista de actividades (activities). 

&#9679; 
getActivities: Este método debe devolver una lista enlazada con todas las actividades de esta instancia. Es decir, devolver el contenido del atributo activities. 

&#9679; 
toString: Este método devuelve la información de un profesor. Debe seguir el siguiente formato: 


[PROFESSOR] name surname (email) Total activities: n 
Donde n corresponde al número de actividades que ha creado el profesor. 

Class Execution 
Esta clase se crea cuando un usuario realiza una entrega y se ejecuta en la aplicación para poder puntuarla. Además, cuando se crea una instancia de esta clase, debe añadir la ejecución (this) dentro de las listas enlazadas que contienen las ejecuciones en las clases User y Activity. 
Asimismo, hay que seguir las siguientes especificaciones: 
&#9679; 
setScore: Si el valor recibido por parámetro (score) no está dentro del rango [0,10], se debe normalizar para que esté dentro de ese rango. Es decir, si es inferior a 0, debe ser 0 y, si es superior a 10, debe ser 10. Una vez normalizado, en caso de que fuera necesario, el método asigna la nota a la ejecución. 

&#9679; 
toString: Este método devuelve la información de una ejecución. Debe seguir el siguiente formato: 



[STUDENT] name surname (email) Total executions: n activityName: activityDescription Total executions: k typeDescription Score: score 
Donde n corresponde al número de ejecuciones que ha llevado a cabo el estudiante y k al número de ejecuciones de la actividad. Fíjate que el formato que se ha proporcionado es el que devolvería la ejecución de una actividad de tipo ActivityQuiz, dependiendo de la actividad, la información puede cambiar por la que le corresponda. 
Class DSLab 
Esta clase ha sufrido una ligera modificación respecto al ejercicio anterior, ya que se han añadido 5 métodos nuevos y 3 nuevos atributos. Del mismo modo que en las clases anteriores, estos tres nuevos atributos deben ser de tipo LinkedList. 
Para poder codificar los nuevos métodos, debes seguir las siguientes indicaciones: 
&#9679; 
addUser: Añade el usuario que recibe por parámetro (user) al final de la lista de usuarios (users). Fíjate que puede contener tanto profesores como estudiantes. 

&#9679; 
getUsers: Este método debe devolver una lista enlazada con todos los usuarios de la aplicación. Es decir, devolver el contenido del atributo users. 

&#9679; 
addActivity: Añade la actividad que recibe por parámetro (activity) al final de la lista de actividades (activities). Además, en caso de que la actividad sea evaluable, también se debe añadir a la lista enlazada de actividades evaluables (evaluableActivities). 

&#9679; 
getActivities: Este método debe devolver una lista enlazada con todas las actividades de la aplicación. Es decir, devolver el contenido del atributo activities. 

&#9679; 
getEvaluableActivities: Este método debe devolver una lista enlazada con todas las actividades evaluables de la aplicación. Es decir, devolver el contenido del atributo evaluableActivities. 





(5 puntos: 2.5 pts. testMiminum; 2.5 pts. testAdvanced) 

Recomendación: Es realmente interesante que en aquellos métodos que sobrescribas antepongas la anotación @Override para documentar que es una sobrescritura y para permitir que el compilador (en definitiva, IntelliJ) pueda hacer comprobaciones extras que te ayuden a hacer un código sin errores. 

Requisito mínimo para evaluar este ejercicio: Este ejercicio contiene 133 test. En la ventana de Gradle, en Task &rarr; verification, encontrarás tres tareas: testSanity, testMinimum y testAdvanced. El requisito mínimo para obtener puntos en este ejercicio es superar todos los test (99) de la tarea testMinimum. 
Los test de testSanity permiten verificar todos los elementos del programa. Estos test comprueban que el esqueleto (i.e. definición de atributos y métodos) sea correcto. 
Los test de testMinimum hacen referencia a todos los test &ldquo;sanity&rdquo; comentados en el párrafo anterior y, además, verifican casi la totalidad de los test contenidos del Ejercicio 1. Para poderlo probar, deberás codificar el esqueleto de todas las clases e interfaces del UML sin la necesidad de desarrollar el cuerpo de los métodos. 
Superado el testMinimum (2.5 puntos), el resto de la nota de este ejercicio (otros 2.5 puntos) se calculará proporcionalmente al número de test superados de testAdvanced (33). Cada test de testAdvanced suma 0.076 puntos. 

Nota: El estudiante puede recibir una penalización de hasta 1 punto de la nota obtenida en este ejercicio en función de la calidad del código proporcionado. 