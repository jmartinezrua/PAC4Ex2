@startuml

' Exceptions
class DSLabException {
    + INVALID_NAME: String = "[ERROR] Name cannot be null, empty, or blank"
    + DSLabException(message: String)
}

class UniversityException {
    + INVALID_DESCRIPTION: String = "[ERROR] Description cannot be null"
    + INVALID_NAME: String = "[ERROR] Name cannot be null, empty, or blank"
    + INVALID_VERSION_MAJOR: String = "[ERROR] Major version cannot be negative"
    + INVALID_ABBREVIATION: String = "[ERROR] Abbreviation must contain 2-6 uppercase letters"
    + INVALID_VERSION_MINOR: String = "[ERROR] Minor version cannot be negative"
    + INVALID_FOUNDATION_DATE: String = "[ERROR] Foundation date cannot be null or in the future"
    + INVALID_VERSION_PATCH: String = "[ERROR] Patch version cannot be negative"
    + INVALID_ADDRESS: String = "[ERROR] Address cannot be null"
    + NO_ENOUGH_CPU: String = "[ERROR] This server does not have enough CPU"
    + INVALID_WEBSITE: String = "[ERROR] Website must be a valid URL"
    + UNIVERSITY_NULL: String = "[ERROR] University cannot be null"
    + UniversityException(message: String)
}

class UserException {
    + INVALID_EMAIL: String = "[ERROR] The email must start with any character and end with @uoc.edu"
    + INVALID_NAME: String = "[ERROR] Name cannot be null, empty, or blank"
    + UserException(message: String)
}

class ActivityException {
    + INVALID_NAME: String = "[ERROR] Name cannot be null, empty, or blank"
    + INVALID_CPP_COMPILER: String = "[ERROR] Compiler cannot be null, empty, or blank"
    + INVALID_CPP_STANDARD: String = "[ERROR] Standard cannot be null, empty, or blank"
    + INVALID_JDK_VERSION: String = "[ERROR] JDK version must be in the format x.y.z where y and z are optional"
    + INVALID_GRADLE_VERSION: String = "[ERROR] Gradle version must be in the format x.y.z where z is optional"
    + INVALID_PYTHON_VERSION: String = "[ERROR] Python version must be in the format x.y.z where z is optional"
    + ActivityException(message: String)
}

' Main Classes
class DSLab {
    - name: String
    - description: String
    - versionMajor: int
    - versionMinor: int
    - versionPatch: int
    - cpu: long
    - university: University
    - status: DSLabStatus
    - users: LinkedList<User>
    - activities: LinkedList<Activity>
    - evaluableActivities: LinkedList<Evaluable>
    + DSLab(name: String, description: String, versionMajor: int, versionMinor: int, versionPatch: int, cpu: long, university: University)
    + getName(): String
    + setName(name: String)
    + getDescription(): String
    + setDescription(description: String)
    + getVersionMajor(): int
    + setVersionMajor(versionMajor: int)
    + getVersionMinor(): int
    + setVersionMinor(versionMinor: int)
    + getVersionPatch(): int
    + setVersionPatch(versionPatch: int)
    + getCpu(): long
    + setCpu(cpu: long)
    + getUniversity(): University
    + setUniversity(university: University)
    + getStatus(): DSLabStatus
    + setStatus(status: DSLabStatus)
    + addUser(user: User)
    + getUsers(): LinkedList<User>
    + addActivity(activity: Activity)
    + getActivities(): LinkedList<Activity>
    + getEvaluableActivities(): LinkedList<Evaluable>
    + toString(): String
}

class University {
    - name: String
    - abbreviation: String
    - foundationDate: LocalDate
    - address: String
    - website: String
    + University(name: String, abbreviation: String, foundationDate: LocalDate, address: String, website: String)
    + getName(): String
    + setName(name: String)
    + getAbbreviation(): String
    + setAbbreviation(abbreviation: String)
    + getFoundationDate(): LocalDate
    + setFoundationDate(foundationDate: LocalDate)
    + getAddress(): String
    + setAddress(address: String)
    + getWebsite(): String
    + setWebsite(website: String)
    + toString(): String
}

' User-related classes
class User {
    - email: String
    - name: String
    - surname: String
    + User(email: String, name: String, surname: String)
    + getEmail(): String
    + setEmail(email: String)
    + getName(): String
    + setName(name: String)
    + getSurname(): String
    + setSurname(surname: String)
    + toString(): String
}

class Professor {
    - activities: LinkedList<Activity>
    + Professor(email: String, name: String, surname: String)
    + addActivity(activity: Activity)
    + getActivities(): LinkedList<Activity>
    + toString(): String
}

class Student {
    - executions: LinkedList<Execution>
    + Student(email: String, name: String, surname: String)
    + addExecution(execution: Execution)
    + getExecutions(): LinkedList<Execution>
    + getLastExecutionSubmitted(): Execution
    + toString(): String
}

' Activity-related classes
class Activity {
    - name: String
    - description: String
    - executions: LinkedList<Execution>
    + Activity(name: String, description: String)
    + getName(): String
    + setName(name: String)
    + getDescription(): String
    + setDescription(description: String)
    + addExecution(execution: Execution)
    + getExecutions(): LinkedList<Execution>
    + clone(): Object
    + toString(): String
}

class Execution {
    - student: Student
    - activity: Activity
    - score: double
    + Execution(score: double, student: Student, activity: Activity)
    + getScore(): double
    + setScore(score: double)
    + getStudent(): Student
    + setStudent(student: Student)
    + getActivity(): Activity
    + setActivity(activity: Activity)
    + toString(): String
}

class ActivityQuiz extends Activity {
    - type: ActivityQuizType
    + ActivityQuiz(name: String, description: String, type: ActivityQuizType)
    + getType(): ActivityQuizType
    + setType(type: ActivityQuizType)
    + toString(): String
}

class ActivityProgramming extends Activity {
    - weight: double
    + ActivityProgramming(name: String, description: String, weight: double)
    + getWeight(): double
    + setWeight(weight: double)
    + toString(): String
}

class ActivityProgrammingCpp extends ActivityProgramming {
    - compiler: String
    - standard: String
    + ActivityProgrammingCpp(name: String, description: String, weight: double, compiler: String, standard: String)
    + getCompiler(): String
    + setCompiler(compiler: String)
    + getStandard(): String
    + setStandard(standard: String)
    + toString(): String
}

class ActivityProgrammingJava extends ActivityProgramming {
    - jdkVersion: String
    - gradleVersion: String
    + ActivityProgrammingJava(name: String, description: String, weight: double, jdkVersion: String, gradleVersion: String)
    + getJdkVersion(): String
    + setJdkVersion(jdkVersion: String)
    + getGradleVersion(): String
    + setGradleVersion(gradleVersion: String)
    + toString(): String
}

class ActivityProgrammingPython extends ActivityProgramming {
    - pythonVersion: String
    - usesVirtualEnv: boolean
    + ActivityProgrammingPython(name: String, description: String, weight: double, pythonVersion: String, usesVirtualEnv: boolean)
    + getPythonVersion(): String
    + setPythonVersion(pythonVersion: String)
    + getUsesVirtualEnv(): boolean
    + setUsesVirtualEnv(usesVirtualEnv: boolean)
    + toString(): String
}

' Interfaces
interface Evaluable {
    + toString(): String
}

' Enums
enum DSLabStatus {
    ACTIVE
    INACTIVE
    MAINTENANCE
}

enum ActivityQuizType {
    MULTIPLE_CHOICE
    TRUE_FALSE
    SHORT_ANSWER
}

' Relationships
DSLab "1" -- "1" University
DSLab "1" -- "*" User
DSLab "1" -- "*" Activity
DSLab "1" -- "*" Evaluable
User "1" -- "*" Execution
Activity "1" -- "*" Execution
Professor --|> User
Student --|> User

@enduml

Conditions******************************************

**Exercise 2 (5 points)**  
Before starting, you must:  

1. Open the PAC4Ex2 project in IntelliJ. In the `edu.uoc.pac4` package located in the `/src/test/java` directory, you will find the file with the unit tests we provide. Copy the `edu.uoc.pac4` package from the `/src/main/java` directory of Exercise 1 in this PEC4 after completing it.  

2. In this exercise, we extend the previous program by adding new classes, interfaces, and methods. The new UML class diagram is included in the zip file of the assignment statement under the name `PAC4Ex2.png`. It is essential to consult it often as it contains information, such as access modifiers for elements, that may not be mentioned in this statement.  

3. To provide a clear structure for the project, we include a screenshot showing all the classes, interfaces, and enumerations to be implemented within their respective packages. You must maintain this structure in your project to successfully execute the test suite:  

---

**Recommendation:** In this exercise, we will learn to use the LinkedList data structure, which allows storing elements in a linked list. You can research more about it in the official Java documentation:  
[LinkedList Documentation](https://docs.oracle.com/javase/8/docs/api/java/util/LinkedList.html).  

Next, we will describe each element in the class diagram and the previous screenshot:  

---

**Interface `Evaluable`**  
This interface declares the method signature for any class whose objects can be evaluated. It must be located in the `edu.uoc.pac4.activity` package.  

---

**Class `ActivityException`**  
This class must define all attributes and constructors shown in the UML diagram and inherit from the `Exception` class, as in the previous exercise.  

---

**Class `Activity`**  
This abstract class cannot be instantiated; instead, its child classes must be instantiated. Thus, it should be declared as abstract. Additionally, it represents an activity that can be executed within the DSLab application. For its implementation, follow the UML diagram and consider these points:  

- The `Activity` class must implement the `Cloneable` interface and include the `clone` method. You can leave its signature for now and implement it later.  
- This class includes an attribute that represents a list of executions to store all the executions of this activity. Use the `LinkedList` data structure for this attribute.  
- **`setName:`** If the `name` parameter is `null`, empty, or consists only of whitespace, the method must throw an `ActivityException` with the message `[ERROR] Name cannot be null, empty or blank`. Otherwise, it should assign the activity name after trimming leading and trailing whitespaces.  
- **`setDescription:`** If the `description` parameter is `null`, the method should assign an empty string. Otherwise, it should assign the trimmed description.  
- **`addExecution:`** This method adds the given `execution` parameter to the end of the linked list of executions.  
- **`getExecutions:`** This method returns a linked list containing all the executions of this instance (i.e., the `executions` attribute).  
- **`clone:`** This method creates a copy of the activity, including all attributes except for the execution list, which should be empty in the copy. Use the `Object` class's `clone` method.  
- **`toString:`** This method returns a string with the activity information in the format:  
  ```
  name: description Total executions: n
  ```
  where `n` is the number of executions of this activity.  

---

**Class `ActivityProgramming`**  
This abstract class inherits from the `Activity` class, allowing access to all its public and protected attributes and methods. Implementation considerations:  

- **`setWeight:`** If the weight of this activity in the final grade is outside the range `[0, 100]`, it should be adjusted to fit within this range before being assigned.  
- **`toString:`** This method returns programming activity information, including inherited activity details, in the format:  
  ```
  name: description Total executions: n (weight%)
  ```


**Enum `ActivityQuizType`**  
This enumeration should be implemented following the UML specifications. Each literal must have the following descriptions:  

- `MULTIPLE_CHOICE` → Collection of questions with multiple choices  
- `TRUE_FALSE` → Collection of questions with true or false answers  
- `SHORT_ANSWER` → Collection of questions with short answers  

Additionally:  

- **`toString:`** This method must return the description of the literal representing the instance.  

---

**Class `ActivityQuiz`**  
This class inherits from the `Activity` class, granting access to all its public and protected attributes and methods. Unlike the parent class, this class is not abstract, so it can be instantiated. Implementation considerations:  

- **`toString:`** This method returns activity information followed by a description of the quiz type. It should follow this format:  
  ```
  name: description Total executions: n typeDescription
  ```

---

**Class `ActivityProgrammingCpp`**  
Implementation considerations:  

- **`setCompiler:`** If the `compiler` parameter is `null`, an empty string, or consists only of whitespaces, the method must throw an `ActivityException` with the message `[ERROR] Compiler cannot be null, empty or blank`. Otherwise, it should assign the compiler name after trimming leading and trailing whitespaces.  
- **`setStandard:`** If the `standard` parameter is `null`, an empty string, or consists only of whitespaces, the method must throw an `ActivityException` with the message `[ERROR] Standard cannot be null, empty or blank`. Otherwise, it should assign the standard after trimming leading and trailing whitespaces.  
- **`toString:`** This method returns information about a C++ programming activity in the following format:  
  ```
  [C++] name: description Total executions: n (weight%) (compiler, standard)
  ```

---

**Class `ActivityProgrammingJava`**  
Implementation considerations:  

- **`setJdkVersion:`** If the `jdkVersion` parameter is `null` or does not represent a valid version, the method must throw an `ActivityException` with the message `[ERROR] JDK version must be in the format x.y.z where y and z are optional`. Otherwise, it should assign the JDK version. A valid JDK version consists only of numbers and dots in a format like `x.y.z`, where `y` and `z` are optional.  
- **`setGradleVersion:`** If the `gradleVersion` parameter is `null` or does not represent a valid version, the method must throw an `ActivityException` with the message `[ERROR] Gradle version must be in the format x.y.z where z is optional`. Otherwise, it should assign the Gradle version. A valid Gradle version consists only of numbers and dots in a format like `x.y.z`, where `z` is optional.  
- **`toString:`** This method returns information about a Java programming activity in the following format:  
  ```
  [Java] name: description Total executions: n (weight%) (jdk-jdkVersion, gradle vgradle)
  ```

---

**Class `ActivityProgrammingPython`**  
Implementation considerations:  

- **`setPythonVersion:`** If the `pythonVersion` parameter is `null` or does not represent a valid version, the method must throw an `ActivityException` with the message `[ERROR] Python version must be in the format x.y.z where z is optional`. Otherwise, it should assign the Python version. A valid Python version consists only of numbers and dots in a format like `x.y.z`, where `z` is optional.  
- **`toString:`** This method returns information about a Python programming activity in the following format:  
  ```
  [Python] name: description Total executions: n (weight%) (pythonVersion, with virtualenv)
  ```
  The string `, with virtualenv` is appended only if the activity requires execution in a virtual environment (`usesVirtualEnv`).  

---

**Class `UserException`**  
This class must define all attributes and constructors shown in the UML diagram and inherit from the `Exception` class, as in the previous exercise. It must be located in the `edu.uoc.pac4.user` package.  

---

**Class `User`**  
This abstract class cannot be instantiated. Implementation considerations:  

- **`setEmail:`** If the `email` parameter is `null` or not valid, the method must throw a `UserException` with the message `[ERROR] The email must start with any character end with @uoc.edu`. Otherwise, it should assign the email. A valid email contains any character before the `@` symbol and ends with `@uoc.edu`.  
- **`setName:`** If the `name` parameter is `null`, empty, or consists only of whitespaces, the method must throw a `UserException` with the message `[ERROR] Name cannot be null, empty or blank`. Otherwise, it should assign the name after trimming whitespaces.  
- **`setSurname:`** If the `surname` parameter is `null`, it should assign an empty string. Otherwise, it should assign the trimmed surname.  
- **`toString:`** This method returns user information in the format:  
  ```
  name surname (email)
  ```

---

**Class `Student`**  
This class inherits from the `User` class and includes an attribute to store executions performed in the application using a `LinkedList`. Implementation considerations:  

- **`addExecution:`** Adds the `execution` parameter to the end of the executions list.  
- **`getExecutions:`** Returns a linked list of all executions of this instance.  
- **`getLastExecutionSubmitted:`** Returns the last execution added to the executions list.  
- **`toString:`** Returns student information in the format:  
  ```
  [STUDENT] name surname (email) Total executions: n
  ```
  where `n` is the number of executions performed by the student.  

---

**Class `Professor`**  
This class inherits from the `User` class and includes an attribute to store created activities using a `LinkedList`. Implementation considerations:  

- **`addActivity:`** Adds the `activity` parameter to the end of the activities list.  
- **`getActivities:`** Returns a linked list of all activities of this instance.  
- **`toString:`** Returns professor information in the format:  
  ```
  [PROFESSOR] name surname (email) Total activities: n
  ```
  where `n` is the number of activities created by the professor.  

---

**Class `Execution`**  
This class is created when a user submits an entry, and it is executed in the application for scoring. Upon creation, the instance (`this`) must be added to the executions list in the `User` and `Activity` classes. Implementation considerations:  

- **`setScore:`** If the `score` parameter is outside the range `[0, 10]`, normalize it to fit within this range before assigning it.  
- **`toString:`** Returns execution information in the format:  
  ```
  [STUDENT] name surname (email) Total executions: n activityName: activityDescription Total executions: k typeDescription Score: score
  ```
  where `n` is the student's execution count and `k` is the activity's execution count.  

---

**Class `DSLab`**  
This class has been slightly modified from the previous exercise with 5 new methods and 3 new attributes, all of which must be of type `LinkedList`. Implementation considerations:  

- **`addUser:`** Adds the `user` parameter to the end of the users list, which may include both professors and students.  
- **`getUsers:`** Returns a linked list of all users in the application.  
- **`addActivity:`** Adds the `activity` parameter to the activities list. If the activity is evaluable, also adds it to the evaluable activities list.  
- **`getActivities:`** Returns a linked list of all activities in the application.  
- **`getEvaluableActivities:`** Returns a linked list of all evaluable activities in the application.  

---

**Evaluation Criteria (5 points)**  
- **2.5 points:** Pass all `testMinimum` cases (99 tests).  
- **2.5 points:** Proportional score for additional `testAdvanced` cases (33 tests). Each test contributes 0.076 points.  
- **Note:** Up to 1 point may be deducted for code quality issues.  

**********************************************************
DSLab code***************************************

package edu.uoc.pac4;

import edu.uoc.pac4.activity.Activity;
import edu.uoc.pac4.activity.Evaluable;
import edu.uoc.pac4.university.University;
import edu.uoc.pac4.DSLabStatus;
import edu.uoc.pac4.user.User;

import java.util.LinkedList;
import java.util.Objects;

public class DSLab {
    public static final long MIN_CPU_REQUIRED = 1073741824L;
    private String name;
    private String description;
    private int versionMajor;
    private int versionMinor;
    private int versionPatch;
    private long cpu;
    private University university;
    private DSLabStatus status;
    private LinkedList<User> users = new LinkedList<>();
    private LinkedList<Activity> activities = new LinkedList<>();
    private LinkedList<Evaluable> evaluableActivities = new LinkedList<>();

    public DSLab(String name, String description, int versionMajor, int versionMinor, int versionPatch, long cpu, University university) throws DSLabException {
        setName(name);
        setDescription(description);
        setVersionMajor(versionMajor);
        setVersionMinor(versionMinor);
        setVersionPatch(versionPatch);
        setCpu(cpu);
        setUniversity(university);
        this.status = DSLabStatus.ACTIVE;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) throws DSLabException {
        if (name == null || name.trim().isEmpty()) {
            throw new DSLabException(DSLabException.INVALID_NAME);
        }
        this.name = name.trim();
    }

    public String getDescription() {
        return description;
    }

    public void setDescription(String description) throws DSLabException {
        if (description == null) {
            throw new DSLabException(DSLabException.INVALID_DESCRIPTION);
        }
        this.description = description;
    }

    public int getVersionMajor() {
        return versionMajor;
    }

    public void setVersionMajor(int versionMajor) throws DSLabException {
        if (versionMajor < 0) {
            throw new DSLabException(DSLabException.INVALID_VERSION_MAJOR);
        }
        this.versionMajor = versionMajor;
    }

    public int getVersionMinor() {
        return versionMinor;
    }

    public void setVersionMinor(int versionMinor) throws DSLabException {
        if (versionMinor < 0) {
            throw new DSLabException(DSLabException.INVALID_VERSION_MINOR);
        }
        this.versionMinor = versionMinor;
    }

    public int getVersionPatch() {
        return versionPatch;
    }

    public void setVersionPatch(int versionPatch) throws DSLabException {
        if (versionPatch < 0) {
            throw new DSLabException(DSLabException.INVALID_VERSION_PATCH);
        }
        this.versionPatch = versionPatch;
    }

    public long getCpu() {
        return cpu;
    }

    public void setCpu(long cpu) throws DSLabException {
        if (cpu < MIN_CPU_REQUIRED) {
            throw new DSLabException(DSLabException.NO_ENOUGH_CPU);
        }
        this.cpu = cpu;
    }

    public University getUniversity() {
        return university;
    }

    public void setUniversity(University university) throws DSLabException {
        if (university == null) {
            throw new DSLabException(DSLabException.UNIVERSITY_NULL);
        }
        this.university = university;
    }

    public DSLabStatus getStatus() {
        return status;
    }

    public void setStatus(DSLabStatus status) {
        this.status = status;
    }

    public void addUser(User user) {
        users.add(user);
    }

    public LinkedList<User> getUsers() {
        return users;
    }

    public void addActivity(Activity activity) {
        activities.add(activity);
    }

    public LinkedList<Activity> getActivities() {
        return activities;
    }

    public LinkedList<Evaluable> getEvaluableActivities() {
        return evaluableActivities;
    }

    @Override
    public String toString() {
        return name + System.lineSeparator() +
                "\tDescription: " + description + System.lineSeparator() +
                "\tVersion: " + getVersion() + System.lineSeparator() +
                "\tStatus: " + status + System.lineSeparator() +
                "\tCPU: " + cpu + System.lineSeparator() +
                "\tUniversity: " + university;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        DSLab dsLab = (DSLab) o;
        return versionMajor == dsLab.versionMajor &&
                versionMinor == dsLab.versionMinor &&
                versionPatch == dsLab.versionPatch &&
                Objects.equals(name, dsLab.name) &&
                Objects.equals(university, dsLab.university);
    }

    protected String getVersion() {
        return versionMajor + "." + versionMinor + "." + versionPatch;
    }

    @Override
    public int hashCode() {
        return Objects.hash(name, versionMajor, versionMinor, versionPatch, university);
    }
}

**************************************

DSLabTest ***************************************

package edu.uoc.pac4;

import edu.uoc.pac4.activity.*;
import edu.uoc.pac4.university.University;
import edu.uoc.pac4.university.UniversityException;
import edu.uoc.pac4.user.Professor;
import edu.uoc.pac4.user.Student;
import edu.uoc.pac4.user.User;
import edu.uoc.pac4.user.UserException;
import org.junit.jupiter.api.*;

import java.lang.reflect.Modifier;
import java.time.LocalDate;
import java.util.Arrays;
import java.util.LinkedList;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.fail;

import static org.junit.jupiter.api.Assertions.*;

@TestMethodOrder(MethodOrderer.OrderAnnotation.class)
public class DSLabTest {

    @Test
    @Tag("sanity")
    @Order(1)
    @DisplayName("Sanity - Fields definition")
    public void checkFieldsSanity() {
        assertEquals(12, DSLab.class.getDeclaredFields().length);

        try {
            assertTrue(Modifier.isPublic(DSLab.class.getDeclaredField("MIN_CPU_REQUIRED").getModifiers()));
            assertTrue(Modifier.isStatic(DSLab.class.getDeclaredField("MIN_CPU_REQUIRED").getModifiers()));
            assertTrue(Modifier.isFinal(DSLab.class.getDeclaredField("MIN_CPU_REQUIRED").getModifiers()));
            assertEquals(long.class, DSLab.class.getDeclaredField("MIN_CPU_REQUIRED").getType());
            assertEquals(1_073_741_824L, DSLab.MIN_CPU_REQUIRED);

            assertTrue(Modifier.isPrivate(DSLab.class.getDeclaredField("name").getModifiers()));
            assertFalse(Modifier.isStatic(DSLab.class.getDeclaredField("name").getModifiers()));
            assertFalse(Modifier.isFinal(DSLab.class.getDeclaredField("name").getModifiers()));
            assertEquals(String.class, DSLab.class.getDeclaredField("name").getType());

            assertTrue(Modifier.isPrivate(DSLab.class.getDeclaredField("description").getModifiers()));
            assertFalse(Modifier.isStatic(DSLab.class.getDeclaredField("description").getModifiers()));
            assertFalse(Modifier.isFinal(DSLab.class.getDeclaredField("description").getModifiers()));
            assertEquals(String.class, DSLab.class.getDeclaredField("description").getType());

            assertTrue(Modifier.isPrivate(DSLab.class.getDeclaredField("versionMajor").getModifiers()));
            assertFalse(Modifier.isStatic(DSLab.class.getDeclaredField("versionMajor").getModifiers()));
            assertFalse(Modifier.isFinal(DSLab.class.getDeclaredField("versionMajor").getModifiers()));
            assertEquals(int.class, DSLab.class.getDeclaredField("versionMajor").getType());

            assertTrue(Modifier.isPrivate(DSLab.class.getDeclaredField("versionMinor").getModifiers()));
            assertFalse(Modifier.isStatic(DSLab.class.getDeclaredField("versionMinor").getModifiers()));
            assertFalse(Modifier.isFinal(DSLab.class.getDeclaredField("versionMinor").getModifiers()));
            assertEquals(int.class, DSLab.class.getDeclaredField("versionMinor").getType());

            assertTrue(Modifier.isPrivate(DSLab.class.getDeclaredField("versionPatch").getModifiers()));
            assertFalse(Modifier.isStatic(DSLab.class.getDeclaredField("versionPatch").getModifiers()));
            assertFalse(Modifier.isFinal(DSLab.class.getDeclaredField("versionPatch").getModifiers()));
            assertEquals(int.class, DSLab.class.getDeclaredField("versionPatch").getType());

            assertTrue(Modifier.isPrivate(DSLab.class.getDeclaredField("cpu").getModifiers()));
            assertFalse(Modifier.isStatic(DSLab.class.getDeclaredField("cpu").getModifiers()));
            assertFalse(Modifier.isFinal(DSLab.class.getDeclaredField("cpu").getModifiers()));
            assertEquals(long.class, DSLab.class.getDeclaredField("cpu").getType());

            assertTrue(Modifier.isPrivate(DSLab.class.getDeclaredField("university").getModifiers()));
            assertFalse(Modifier.isStatic(DSLab.class.getDeclaredField("university").getModifiers()));
            assertFalse(Modifier.isFinal(DSLab.class.getDeclaredField("university").getModifiers()));
            assertEquals(University.class, DSLab.class.getDeclaredField("university").getType());

            assertTrue(Modifier.isPrivate(DSLab.class.getDeclaredField("status").getModifiers()));
            assertFalse(Modifier.isStatic(DSLab.class.getDeclaredField("status").getModifiers()));
            assertFalse(Modifier.isFinal(DSLab.class.getDeclaredField("status").getModifiers()));
            assertEquals(DSLabStatus.class, DSLab.class.getDeclaredField("status").getType());

            assertTrue(Modifier.isPrivate(DSLab.class.getDeclaredField("users").getModifiers()));
            assertFalse(Modifier.isStatic(DSLab.class.getDeclaredField("users").getModifiers()));
            assertFalse(Modifier.isFinal(DSLab.class.getDeclaredField("users").getModifiers()));
            assertEquals("java.util.LinkedList", DSLab.class.getDeclaredField("users").getType().getName());

            assertTrue(Modifier.isPrivate(DSLab.class.getDeclaredField("activities").getModifiers()));
            assertFalse(Modifier.isStatic(DSLab.class.getDeclaredField("activities").getModifiers()));
            assertFalse(Modifier.isFinal(DSLab.class.getDeclaredField("activities").getModifiers()));
            assertEquals(LinkedList.class, DSLab.class.getDeclaredField("activities").getType());

            assertTrue(Modifier.isPrivate(DSLab.class.getDeclaredField("evaluableActivities").getModifiers()));
            assertFalse(Modifier.isStatic(DSLab.class.getDeclaredField("evaluableActivities").getModifiers()));
            assertFalse(Modifier.isFinal(DSLab.class.getDeclaredField("evaluableActivities").getModifiers()));
            assertEquals(LinkedList.class, DSLab.class.getDeclaredField("evaluableActivities").getType());
        } catch (NoSuchFieldException e) {
            fail("[ERROR] There is some problem with the definition of the attributes: " + e.getMessage());
        }
    }

    @Test
    @Tag("sanity")
    @Order(2)
    @DisplayName("Sanity - Methods definition")
    void checkMethodsSanity() {
        assertEquals(1, DSLab.class.getDeclaredConstructors().length);
        assertEquals(24, Arrays.stream(DSLab.class.getDeclaredMethods()).filter(m -> Modifier.isPublic(m.getModifiers())).toList().size());

        try {
            assertTrue(Modifier.isPublic(DSLab.class.getDeclaredMethod("getName").getModifiers()));
            assertFalse(Modifier.isStatic(DSLab.class.getDeclaredMethod("getName").getModifiers()));
            assertFalse(Modifier.isFinal(DSLab.class.getDeclaredMethod("getName").getModifiers()));
            assertEquals(String.class, DSLab.class.getDeclaredMethod("getName").getReturnType());

            assertTrue(Modifier.isPublic(DSLab.class.getDeclaredMethod("setName", String.class).getModifiers()));
            assertFalse(Modifier.isStatic(DSLab.class.getDeclaredMethod("setName", String.class).getModifiers()));
            assertFalse(Modifier.isFinal(DSLab.class.getDeclaredMethod("setName", String.class).getModifiers()));
            assertEquals(void.class, DSLab.class.getDeclaredMethod("setName", String.class).getReturnType());

            assertTrue(Modifier.isPublic(DSLab.class.getDeclaredMethod("getDescription").getModifiers()));
            assertFalse(Modifier.isStatic(DSLab.class.getDeclaredMethod("getDescription").getModifiers()));
            assertFalse(Modifier.isFinal(DSLab.class.getDeclaredMethod("getDescription").getModifiers()));
            assertEquals(String.class, DSLab.class.getDeclaredMethod("getDescription").getReturnType());

            assertTrue(Modifier.isPublic(DSLab.class.getDeclaredMethod("setDescription", String.class).getModifiers()));
            assertFalse(Modifier.isStatic(DSLab.class.getDeclaredMethod("setDescription", String.class).getModifiers()));
            assertFalse(Modifier.isFinal(DSLab.class.getDeclaredMethod("setDescription", String.class).getModifiers()));
            assertEquals(void.class, DSLab.class.getDeclaredMethod("setDescription", String.class).getReturnType());

            assertTrue(Modifier.isPublic(DSLab.class.getDeclaredMethod("getVersionMajor").getModifiers()));
            assertFalse(Modifier.isStatic(DSLab.class.getDeclaredMethod("getVersionMajor").getModifiers()));
            assertFalse(Modifier.isFinal(DSLab.class.getDeclaredMethod("getVersionMajor").getModifiers()));
            assertEquals(int.class, DSLab.class.getDeclaredMethod("getVersionMajor").getReturnType());

            assertTrue(Modifier.isPublic(DSLab.class.getDeclaredMethod("setVersionMajor", int.class).getModifiers()));
            assertFalse(Modifier.isStatic(DSLab.class.getDeclaredMethod("setVersionMajor", int.class).getModifiers()));
            assertFalse(Modifier.isFinal(DSLab.class.getDeclaredMethod("setVersionMajor", int.class).getModifiers()));
            assertEquals(void.class, DSLab.class.getDeclaredMethod("setVersionMajor", int.class).getReturnType());

            assertTrue(Modifier.isPublic(DSLab.class.getDeclaredMethod("getVersionMinor").getModifiers()));
            assertFalse(Modifier.isStatic(DSLab.class.getDeclaredMethod("getVersionMinor").getModifiers()));
            assertFalse(Modifier.isFinal(DSLab.class.getDeclaredMethod("getVersionMinor").getModifiers()));
            assertEquals(int.class, DSLab.class.getDeclaredMethod("getVersionMinor").getReturnType());

            assertTrue(Modifier.isPublic(DSLab.class.getDeclaredMethod("setVersionMinor", int.class).getModifiers()));
            assertFalse(Modifier.isStatic(DSLab.class.getDeclaredMethod("setVersionMinor", int.class).getModifiers()));
            assertFalse(Modifier.isFinal(DSLab.class.getDeclaredMethod("setVersionMinor", int.class).getModifiers()));
            assertEquals(void.class, DSLab.class.getDeclaredMethod("setVersionMinor", int.class).getReturnType());

            assertTrue(Modifier.isPublic(DSLab.class.getDeclaredMethod("getVersionPatch").getModifiers()));
            assertFalse(Modifier.isStatic(DSLab.class.getDeclaredMethod("getVersionPatch").getModifiers()));
            assertFalse(Modifier.isFinal(DSLab.class.getDeclaredMethod("getVersionPatch").getModifiers()));
            assertEquals(int.class, DSLab.class.getDeclaredMethod("getVersionPatch").getReturnType());

            assertTrue(Modifier.isPublic(DSLab.class.getDeclaredMethod("setVersionPatch", int.class).getModifiers()));
            assertFalse(Modifier.isStatic(DSLab.class.getDeclaredMethod("setVersionPatch", int.class).getModifiers()));
            assertFalse(Modifier.isFinal(DSLab.class.getDeclaredMethod("setVersionPatch", int.class).getModifiers()));
            assertEquals(void.class, DSLab.class.getDeclaredMethod("setVersionPatch", int.class).getReturnType());

            assertTrue(Modifier.isPublic(DSLab.class.getDeclaredMethod("getVersion").getModifiers()));
            assertFalse(Modifier.isStatic(DSLab.class.getDeclaredMethod("getVersion").getModifiers()));
            assertFalse(Modifier.isFinal(DSLab.class.getDeclaredMethod("getVersion").getModifiers()));
            assertEquals(String.class, DSLab.class.getDeclaredMethod("getVersion").getReturnType());

            assertTrue(Modifier.isPublic(DSLab.class.getDeclaredMethod("getCpu").getModifiers()));
            assertFalse(Modifier.isStatic(DSLab.class.getDeclaredMethod("getCpu").getModifiers()));
            assertFalse(Modifier.isFinal(DSLab.class.getDeclaredMethod("getCpu").getModifiers()));
            assertEquals(long.class, DSLab.class.getDeclaredMethod("getCpu").getReturnType());

            assertTrue(Modifier.isPublic(DSLab.class.getDeclaredMethod("setCpu", long.class).getModifiers()));
            assertFalse(Modifier.isStatic(DSLab.class.getDeclaredMethod("setCpu", long.class).getModifiers()));
            assertFalse(Modifier.isFinal(DSLab.class.getDeclaredMethod("setCpu", long.class).getModifiers()));
            assertEquals(void.class, DSLab.class.getDeclaredMethod("setCpu", long.class).getReturnType());

            assertTrue(Modifier.isPublic(DSLab.class.getDeclaredMethod("getUniversity").getModifiers()));
            assertFalse(Modifier.isStatic(DSLab.class.getDeclaredMethod("getUniversity").getModifiers()));
            assertFalse(Modifier.isFinal(DSLab.class.getDeclaredMethod("getUniversity").getModifiers()));
            assertEquals(University.class, DSLab.class.getDeclaredMethod("getUniversity").getReturnType());

            assertTrue(Modifier.isPublic(DSLab.class.getDeclaredMethod("setUniversity", University.class).getModifiers()));
            assertFalse(Modifier.isStatic(DSLab.class.getDeclaredMethod("setUniversity", University.class).getModifiers()));
            assertFalse(Modifier.isFinal(DSLab.class.getDeclaredMethod("setUniversity", University.class).getModifiers()));
            assertEquals(void.class, DSLab.class.getDeclaredMethod("setUniversity", University.class).getReturnType());

            assertTrue(Modifier.isPublic(DSLab.class.getDeclaredMethod("getStatus").getModifiers()));
            assertFalse(Modifier.isStatic(DSLab.class.getDeclaredMethod("getStatus").getModifiers()));
            assertFalse(Modifier.isFinal(DSLab.class.getDeclaredMethod("getStatus").getModifiers()));
            assertEquals(DSLabStatus.class, DSLab.class.getDeclaredMethod("getStatus").getReturnType());

            assertTrue(Modifier.isPublic(DSLab.class.getDeclaredMethod("setStatus", DSLabStatus.class).getModifiers()));
            assertFalse(Modifier.isStatic(DSLab.class.getDeclaredMethod("setStatus", DSLabStatus.class).getModifiers()));
            assertFalse(Modifier.isFinal(DSLab.class.getDeclaredMethod("setStatus", DSLabStatus.class).getModifiers()));
            assertEquals(void.class, DSLab.class.getDeclaredMethod("setStatus", DSLabStatus.class).getReturnType());

            assertTrue(Modifier.isPublic(DSLab.class.getDeclaredMethod("toString").getModifiers()));
            assertFalse(Modifier.isStatic(DSLab.class.getDeclaredMethod("toString").getModifiers()));
            assertFalse(Modifier.isFinal(DSLab.class.getDeclaredMethod("toString").getModifiers()));
            assertEquals(String.class, DSLab.class.getDeclaredMethod("toString").getReturnType());

            assertTrue(Modifier.isPublic(DSLab.class.getDeclaredMethod("equals", Object.class).getModifiers()));
            assertFalse(Modifier.isStatic(DSLab.class.getDeclaredMethod("equals", Object.class).getModifiers()));
            assertFalse(Modifier.isFinal(DSLab.class.getDeclaredMethod("equals", Object.class).getModifiers()));
            assertEquals(boolean.class, DSLab.class.getDeclaredMethod("equals", Object.class).getReturnType());

            assertTrue(Modifier.isPublic(DSLab.class.getDeclaredMethod("addUser", User.class).getModifiers()));
            assertFalse(Modifier.isStatic(DSLab.class.getDeclaredMethod("addUser", User.class).getModifiers()));
            assertFalse(Modifier.isFinal(DSLab.class.getDeclaredMethod("addUser", User.class).getModifiers()));
            assertEquals(void.class, DSLab.class.getDeclaredMethod("addUser", User.class).getReturnType());

            assertTrue(Modifier.isPublic(DSLab.class.getDeclaredMethod("getUsers").getModifiers()));
            assertFalse(Modifier.isStatic(DSLab.class.getDeclaredMethod("getUsers").getModifiers()));
            assertFalse(Modifier.isFinal(DSLab.class.getDeclaredMethod("getUsers").getModifiers()));
            assertEquals(LinkedList.class, DSLab.class.getDeclaredMethod("getUsers").getReturnType());

            assertTrue(Modifier.isPublic(DSLab.class.getDeclaredMethod("addActivity", Activity.class).getModifiers()));
            assertFalse(Modifier.isStatic(DSLab.class.getDeclaredMethod("addActivity", Activity.class).getModifiers()));
            assertFalse(Modifier.isFinal(DSLab.class.getDeclaredMethod("addActivity", Activity.class).getModifiers()));
            assertEquals(void.class, DSLab.class.getDeclaredMethod("addActivity", Activity.class).getReturnType());

            assertTrue(Modifier.isPublic(DSLab.class.getDeclaredMethod("getActivities").getModifiers()));
            assertFalse(Modifier.isStatic(DSLab.class.getDeclaredMethod("getActivities").getModifiers()));
            assertFalse(Modifier.isFinal(DSLab.class.getDeclaredMethod("getActivities").getModifiers()));
            assertEquals(LinkedList.class, DSLab.class.getDeclaredMethod("getActivities").getReturnType());

            assertTrue(Modifier.isPublic(DSLab.class.getDeclaredMethod("getEvaluableActivities").getModifiers()));
            assertFalse(Modifier.isStatic(DSLab.class.getDeclaredMethod("getEvaluableActivities").getModifiers()));
            assertFalse(Modifier.isFinal(DSLab.class.getDeclaredMethod("getEvaluableActivities").getModifiers()));
            assertEquals(LinkedList.class, DSLab.class.getDeclaredMethod("getEvaluableActivities").getReturnType());
        } catch (Exception e) {
            fail("[ERROR] There is some problem with the definition of the methods: " + e.getMessage());
        }
    }

    @Test
    @Tag("minimum")
    @Order(3)
    @DisplayName("Minimum - Valid parameters")
    void testDSLabCreationValidParameters() throws DSLabException, UniversityException {
        University university = new University("Universitat Oberta de Catalunya", "UOC", LocalDate.of(1994, 10, 6), "Av. Tibidabo, 39", "www.uoc.edu");
        DSLab dsLab = new DSLab("DSLab", "DSLab description", 1, 0, 0, 2_147_483_648L, university);

        assertEquals("DSLab", dsLab.getName());
        assertEquals("DSLab description", dsLab.getDescription());
        assertEquals(1, dsLab.getVersionMajor());
        assertEquals(0, dsLab.getVersionMinor());
        assertEquals(0, dsLab.getVersionPatch());
        assertEquals("1.0.0", dsLab.getVersion());
        assertEquals(2_147_483_648L, dsLab.getCpu());
        assertEquals(university, dsLab.getUniversity());
        assertEquals(DSLabStatus.ACTIVE, dsLab.getStatus());
    }

    @Test
    @Tag("minimum")
    @Order(4)
    @DisplayName("Minimum - Name")
    void testDSLabCreationName() throws DSLabException, UniversityException {
        University university = new University("Universitat Oberta de Catalunya", "UOC", LocalDate.of(1994, 10, 6), "Av. Tibidabo, 39", "www.uoc.edu");

        DSLabException exception = assertThrows(DSLabException.class, () -> new DSLab(null, "DSLab description", 1, 0, 0, 2_147_483_648L, university));
        assertEquals("[ERROR] Name cannot be null, empty or blank", exception.getMessage());

        assertThrows(DSLabException.class, () -> new DSLab("", "DSLab description", 1, 0, 0, 2_147_483_648L, university));
        assertThrows(DSLabException.class, () -> new DSLab("  ", "DSLab description", 1, 0, 0, 2_147_483_648L, university));

        DSLab dsLab = new DSLab("DSLab", "DSLab description", 1, 0, 0, 2_147_483_648L, university);
        assertEquals("DSLab", dsLab.getName());

        dsLab.setName("DSLab 2");
        assertEquals("DSLab 2", dsLab.getName());

        dsLab.setName("   DSLab  ");
        assertEquals("DSLab", dsLab.getName());

        assertThrows(DSLabException.class, () -> dsLab.setName(null));
        assertThrows(DSLabException.class, () -> dsLab.setName(""));
        assertThrows(DSLabException.class, () -> dsLab.setName("  "));

        assertEquals("DSLab", dsLab.getName());
    }

    @Test
    @Tag("minimum")
    @Order(5)
    @DisplayName("Minimum - Description")
    void testDSLabCreationDescription() throws DSLabException, UniversityException {
        University university = new University("Universitat Oberta de Catalunya", "UOC", LocalDate.of(1994, 10, 6), "Av. Tibidabo, 39", "www.uoc.edu");

        DSLabException exception = assertThrows(DSLabException.class, () -> new DSLab("DSLab", null, 1, 0, 0, 2_147_483_648L, university));
        assertEquals("[ERROR] Description cannot be null", exception.getMessage());

        DSLab dsLab = new DSLab("DSLab", "DSLab description", 1, 0, 0, 2_147_483_648L, university);
        assertEquals("DSLab description", dsLab.getDescription());

        dsLab.setDescription("DSLab description 2");
        assertEquals("DSLab description 2", dsLab.getDescription());

        dsLab.setDescription("   DSLab description  ");
        assertEquals("   DSLab description  ", dsLab.getDescription());

        assertThrows(DSLabException.class, () -> dsLab.setDescription(null));

        assertEquals("   DSLab description  ", dsLab.getDescription());
    }

    @Test
    @Tag("minimum")
    @Order(6)
    @DisplayName("Minimum - Version major")
    void testDSLabCreationVersionMajor() throws DSLabException, UniversityException {
        University university = new University("Universitat Oberta de Catalunya", "UOC", LocalDate.of(1994, 10, 6), "Av. Tibidabo, 39", "www.uoc.edu");

        DSLabException exception = assertThrows(DSLabException.class, () -> new DSLab("DSLab", "DSLab description", -1, 0, 0, 2_147_483_648L, university));
        assertEquals("[ERROR] Major version cannot be negative", exception.getMessage());

        assertThrows(DSLabException.class, () -> new DSLab("DSLab", "DSLab description", -10, 0, 0, 2_147_483_648L, university));

        DSLab dsLab = new DSLab("DSLab", "DSLab description", 1, 0, 0, 2_147_483_648L, university);
        assertEquals(1, dsLab.getVersionMajor());

        dsLab.setVersionMajor(2);
        assertEquals(2, dsLab.getVersionMajor());

        assertThrows(DSLabException.class, () -> dsLab.setVersionMajor(-1));
        assertThrows(DSLabException.class, () -> dsLab.setVersionMajor(-10));

        assertEquals(2, dsLab.getVersionMajor());
    }

    @Test
    @Tag("minimum")
    @Order(7)
    @DisplayName("Minimum - Version minor")
    void testDSLabCreationVersionMinor() throws DSLabException, UniversityException {
        University university = new University("Universitat Oberta de Catalunya", "UOC", LocalDate.of(1994, 10, 6), "Av. Tibidabo, 39", "www.uoc.edu");

        DSLabException exception = assertThrows(DSLabException.class, () -> new DSLab("DSLab", "DSLab description", 1, -1, 0, 2_147_483_648L, university));
        assertEquals("[ERROR] Minor version cannot be negative", exception.getMessage());

        assertThrows(DSLabException.class, () -> new DSLab("DSLab", "DSLab description", 1, -10, 0, 2_147_483_648L, university));

        DSLab dsLab = new DSLab("DSLab", "DSLab description", 1, 0, 0, 2_147_483_648L, university);
        assertEquals(0, dsLab.getVersionMinor());

        dsLab.setVersionMinor(2);
        assertEquals(2, dsLab.getVersionMinor());

        assertThrows(DSLabException.class, () -> dsLab.setVersionMinor(-1));
        assertThrows(DSLabException.class, () -> dsLab.setVersionMinor(-10));

        assertEquals(2, dsLab.getVersionMinor());
    }

    @Test
    @Tag("minimum")
    @Order(8)
    @DisplayName("Minimum - Version patch")
    void testDSLabCreationVersionPatch() throws DSLabException, UniversityException {
        University university = new University("Universitat Oberta de Catalunya", "UOC", LocalDate.of(1994, 10, 6), "Av. Tibidabo, 39", "www.uoc.edu");

        DSLabException exception = assertThrows(DSLabException.class, () -> new DSLab("DSLab", "DSLab description", 1, 0, -1, 2_147_483_648L, university));
        assertEquals("[ERROR] Patch version cannot be negative", exception.getMessage());

        assertThrows(DSLabException.class, () -> new DSLab("DSLab", "DSLab description", 1, 0, -10, 2_147_483_648L, university));

        DSLab dsLab = new DSLab("DSLab", "DSLab description", 1, 0, 0, 2_147_483_648L, university);
        assertEquals(0, dsLab.getVersionPatch());

        dsLab.setVersionPatch(2);
        assertEquals(2, dsLab.getVersionPatch());

        assertThrows(DSLabException.class, () -> dsLab.setVersionPatch(-1));
        assertThrows(DSLabException.class, () -> dsLab.setVersionPatch(-10));

        assertEquals(2, dsLab.getVersionPatch());
    }

    @Test
    @Tag("minimum")
    @Order(9)
    @DisplayName("Minimum - CPU")
    void testDSLabCreationCPU() throws DSLabException, UniversityException {
        University university = new University("Universitat Oberta de Catalunya", "UOC", LocalDate.of(1994, 10, 6), "Av. Tibidabo, 39", "www.uoc.edu");

        DSLabException exception = assertThrows(DSLabException.class, () -> new DSLab("DSLab", "DSLab description", 1, 0, 0, 0, university));
        assertEquals("[ERROR] This server does not have enough CPU", exception.getMessage());

        assertThrows(DSLabException.class, () -> new DSLab("DSLab", "DSLab description", 1, 0, 0, 1_073_741_823L, university));

        DSLab dsLab = new DSLab("DSLab", "DSLab description", 1, 0, 0, 1_073_741_824L, university);
        assertEquals(1_073_741_824L, dsLab.getCpu());

        dsLab.setCpu(4_294_967_296L);
        assertEquals(4_294_967_296L, dsLab.getCpu());

        assertThrows(DSLabException.class, () -> dsLab.setCpu(-1));
        assertThrows(DSLabException.class, () -> dsLab.setCpu(1_073_741_823L));

        assertEquals(4_294_967_296L, dsLab.getCpu());
    }

    @Test
    @Tag("minimum")
    @Order(10)
    @DisplayName("Minimum - University")
    void testDSLabCreationUniversity() throws DSLabException, UniversityException {
        DSLabException exception = assertThrows(DSLabException.class, () -> new DSLab("DSLab", "DSLab description", 1, 0, 0, 2_147_483_648L, null));
        assertEquals("[ERROR] University cannot be null", exception.getMessage());

        University university = new University("Universitat Oberta de Catalunya", "UOC", LocalDate.of(1994, 10, 6), "Av. Tibidabo, 39", "www.uoc.edu");
        DSLab dsLab = new DSLab("DSLab", "DSLab description", 1, 0, 0, 2_147_483_648L, university);
        assertEquals(university, dsLab.getUniversity());

        University university2 = new University("Virtual University", "VU", LocalDate.of(1450, 3, 3), "Wirtland", "https://www.virtualuniversity.wirtland");
        dsLab.setUniversity(university2);
        assertEquals(university2, dsLab.getUniversity());

        assertThrows(DSLabException.class, () -> dsLab.setUniversity(null));

        assertEquals(university2, dsLab.getUniversity());
    }

    @Test
    @Tag("minimum")
    @Order(11)
    @DisplayName("Minimum - Status")
    void testDSLabCreationStatus() throws DSLabException, UniversityException {
        University university = new University("Universitat Oberta de Catalunya", "UOC", LocalDate.of(1994, 10, 6), "Av. Tibidabo, 39", "www.uoc.edu");
        DSLab dsLab = new DSLab("DSLab", "DSLab description", 1, 0, 0, 2_147_483_648L, university);

        assertEquals(DSLabStatus.ACTIVE, dsLab.getStatus());

        dsLab.setStatus(DSLabStatus.INACTIVE);
        assertEquals(DSLabStatus.INACTIVE, dsLab.getStatus());

        dsLab.setStatus(DSLabStatus.ACTIVE);
        assertEquals(DSLabStatus.ACTIVE, dsLab.getStatus());

        dsLab.setStatus(DSLabStatus.MAINTENANCE);
        assertEquals(DSLabStatus.MAINTENANCE, dsLab.getStatus());
    }

    @Test
    @Tag("minimum")
    @Order(12)
    @DisplayName("Minimum - Version")
    void testDSLabCreationVersion() throws DSLabException, UniversityException {
        University university = new University("Universitat Oberta de Catalunya", "UOC", LocalDate.of(1994, 10, 6), "Av. Tibidabo, 39", "www.uoc.edu");
        DSLab dsLab = new DSLab("DSLab", "DSLab description", 1, 2, 3, 2_147_483_648L, university);

        assertEquals("1.2.3", dsLab.getVersion());

        dsLab.setVersionMajor(2);
        assertEquals("2.2.3", dsLab.getVersion());

        dsLab.setVersionMinor(1);
        assertEquals("2.1.3", dsLab.getVersion());

        dsLab.setVersionPatch(1);
        assertEquals("2.1.1", dsLab.getVersion());
    }

    @Test
    @Tag("advanced")
    @Order(13)
    @DisplayName("Advanced - Users")
    void testDSLabCreationUsers() throws DSLabException, UniversityException, UserException {
        University university = new University("Universitat Oberta de Catalunya", "UOC", LocalDate.of(1994, 10, 6), "Av. Tibidabo, 39", "www.uoc.edu");
        DSLab dsLab = new DSLab("DSLab", "DSLab description", 1, 0, 0, 2_147_483_648L, university);

        assertEquals(0, dsLab.getUsers().size());

        Professor professor = new Professor("professor@uoc.edu", "Name", "Surname");
        dsLab.addUser(professor);

        assertEquals(1, dsLab.getUsers().size());
        assertEquals(professor, dsLab.getUsers().getFirst());

        Student student = new Student("student@uoc.edu", "Name", "Surname");
        dsLab.addUser(student);

        assertEquals(2, dsLab.getUsers().size());
        assertEquals(professor, dsLab.getUsers().getFirst());
        assertEquals(student, dsLab.getUsers().getLast());
    }

    @Test
    @Tag("advanced")
    @Order(14)
    @DisplayName("Advanced - Activities")
    void testDSLabCreationActivities() throws DSLabException, UniversityException, UserException, ActivityException {
        University university = new University("Universitat Oberta de Catalunya", "UOC", LocalDate.of(1994, 10, 6), "Av. Tibidabo, 39", "www.uoc.edu");
        DSLab dsLab = new DSLab("DSLab", "DSLab description", 1, 0, 0, 2_147_483_648L, university);

        assertEquals(0, dsLab.getActivities().size());

        ActivityQuiz activity = new ActivityQuiz("Activity 1", "Description of Activity 1", ActivityQuizType.MULTIPLE_CHOICE);
        dsLab.addActivity(activity);

        assertEquals(1, dsLab.getActivities().size());
        assertEquals(activity, dsLab.getActivities().getFirst());

        ActivityProgrammingCpp activity2 = new ActivityProgrammingCpp("Activity 2", "Description of Activity 2", 25.0, "clang", "C++11");
        dsLab.addActivity(activity2);

        assertEquals(2, dsLab.getActivities().size());
        assertEquals(activity, dsLab.getActivities().getFirst());
        assertEquals(activity2, dsLab.getActivities().getLast());
    }

    @Test
    @Tag("advanced")
    @Order(15)
    @DisplayName("Advanced - Evaluable activities")
    void testDSLabCreationEvaluableActivities() throws DSLabException, UniversityException, UserException, ActivityException {
        University university = new University("Universitat Oberta de Catalunya", "UOC", LocalDate.of(1994, 10, 6), "Av. Tibidabo, 39", "www.uoc.edu");
        DSLab dsLab = new DSLab("DSLab", "DSLab description", 1, 0, 0, 2_147_483_648L, university);

        assertEquals(0, dsLab.getEvaluableActivities().size());

        ActivityQuiz activity = new ActivityQuiz("Activity 1", "Description of Activity 1", ActivityQuizType.MULTIPLE_CHOICE);
        dsLab.addActivity(activity);

        assertEquals(1, dsLab.getActivities().size());
        assertEquals(0, dsLab.getEvaluableActivities().size());

        ActivityProgrammingCpp activity2 = new ActivityProgrammingCpp("Activity 2", "Description of Activity 2", 25.0, "clang", "C++11");
        dsLab.addActivity(activity2);

        assertEquals(2, dsLab.getActivities().size());
        assertEquals(1, dsLab.getEvaluableActivities().size());
        assertEquals(activity2, dsLab.getEvaluableActivities().getFirst());
    }

}



